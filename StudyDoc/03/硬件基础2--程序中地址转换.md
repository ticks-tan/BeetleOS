# 程序中的地址转换

CPU执行程序、处理数据都需要从内存中获取数据，但随着计算机发展，单道程序已经无法满足了。但在多道程序并发下，程序的地址访问就有问题了：

1. 程序链接后地址就确定了，如果多个程序都从某处相同地址装载后运行，如何保证地址不冲突。
2. 如何保证不同程序不会读写其他程序的内存空间。
3. 如何解决内存容量，如果每个程序采用不同地址，随着程序运行，内存越来越大，最后内存装不下。
4. 程序不止一两个，也不止在一台计算机上运行，移植到其他不同内存的计算上怎么解决。

一个比较好的解决方案就是使用**虚拟地址**，让所有程序各自享有从0到最大地址的空间（假的，被操作系统欺骗），且程序地址空间是独立的，私有的，其他程序看不到，也访问不了（共享除外），这个地址空间与其他程序及计算机无关，所以程序放到其他计算机上仍能正确访问地址。

## 虚拟地址

虚拟地址是虚拟出的一个地址，如果现在使用 `gcc` 编译一个C文件，然后使用 `objdump` 反汇编，观察文件就会发现其中使用的便是虚拟地址。

不同操作系统对于虚拟地址空间可能不同，但是具体的处理已经由开发工具链解决了，不需要我们关心。

## 虚拟地址到物理地址转换

内存只认识物理地址，虚拟地址是我们想出的一种逻辑地址，所以需要实现虚拟地址到物理地址转换才能正确访问。

如果全部由软件实现，则运行效率会很低，全部由硬件实现又失去了灵活性，所以采用了软硬结合（硬件MMU模块+软件页表）的方式实现，这就是**MMU内存管理单元** 。MMU工作原理类似于一个函数，输入虚拟地址，输出对应物理地址：

![MMU原理架构图](../../static/imgs/03/02/030201.webp)

其中**地址转换表存放在物理内存中，方便软件操控**，所以使用MMU之前需要初始化好地址转换表。

对于地址转换表的实现，有几种方案：

- 一个虚拟地址对应一个物理地址

    这种方案由于地址转换表本身会占有空间，光地址转换表本身就把物理内存耗光了，所以直接淘汰。

- 使用保护模式下的分段方式，一个虚拟地址段基址对应一个物理段基址

    由于段描述符中段长度不一，物理段基址长短不一，不方便管理。

- 使用分页模型

    分页模式下，把虚拟地址空间和物理地址空间都分为相同大小的多个块，称为**页**，按照一定策略进行虚拟页与物理页的转换。根据软件配置不同，可以分为不同大小块，如 `4KB` 、`2MB` 、`4MB` 、`1GB` 。这也是现代操作系统普遍采用的内存模型。

分页模式下，结合MMU后就如下图所示：

![分页模型框架](../../static/imgs/03/02/030202.webp)

分页模型的地址转换关系表中就只需要存放虚拟页对应的物理页即可，这样在`16GB`内存下，需要`4GB`存放地址转换关系表，当然现代操作系统不会直接这么干，会有很多其他优化。

## MMU

MMU是由硬件逻辑电路实现的一个地址转换器件，输入虚拟地址将其转换为实际物理地址。根据实现方式不同，MMU可以是独立芯片，也可以直接集成到其他芯片内部，而X86、ARM系列就是直接将MMU集成到CPU内部。

X86 CPU如果要开启MMU,就必须进入保护模式或长模式，实模式下使用真实物理地址，所以不能使用MMU 。保护模式下使用的是分段模型，不适合MMU的分页模式，保护模式下使用MMU需要使用保护模式的平坦模式，跟长模式下忽略段基址和段长度类似。

保护模式下可以不开启MMU，此时分段模型产生的线性地址就是物理地址，但是长模式下段基址和段长度无效弱化了地址空间的隔离，所以长模式下开启MMU是必须的。

### MMU页表

**地址转换关系表**又叫**页表**，描述了虚拟地址页到物理地址页的映射关系。

页表放在物理内存中，为节省物理内存、增加灵活性，页表不是直接存放虚拟地址到物理地址对应关系，只存放物理地址，页表是分级的，MMU根据虚拟地址索引查找页表，返回物理页面。总体结构如下：

![MMU页表结构](../../static/imgs/03/02/030203.webp)

虚拟地址分为几个不同的位段，从左到右依次索引顶级页目录、中间页目录、页表，最后一个位段为物理页内偏移。

## X86 保护模式下分页

保护模式下为32位地址空间，最多 4GB - 1 大小空间，分页大小有两种，`4KB` 和 `4MB` 大小，分页大小不同会影响虚拟地址位段分布和页表目录级数，但是虚拟页和物理页大小都是相等的。

### 保护模式 4KB 分页

4KB 分页下，32位虚拟地址被分为3个位段：**页目录索引、页表索引、页内偏移** 。

只有一级页目录，包含1024个条目，每个条目指向一个页表，每个页表包含1024个页表项，每个页表项指向一个物理页面，一共 $1024*1024*4KB = 4GB$ 大小，结构如下：

![保护模式4kb分页结构](../../static/imgs/03/02/030204.webp)

页目录索引占10位，最多表示1024个索引，页表索引也为10位，表示1024个页表项，页内偏移12位刚好表示4KB大小地址，一个物理页内地址都能由偏移指出。

`CR3` 为CPU中一个32位寄存器，CPU通过这个寄存器找到页目录物理基地址。32位 4KB 分页下 `CR3` 、页目录项、页表项 结构如下：

![32位4KB分页下结构](../../static/imgs/03/02/030204.jpg)

页目录表项和页表项都是32位4字节，1024个项为 $4*1024 = 2^2 * 2^{10} = 1000000000000(2进制)$ ，因此它们的地址都是4KB对齐的，低12位都为0,可另作它用，表示页面相关属性，如上图。

### 保护模式 4MB 分页

分页页面变大，页表级数页也相应减少，虚拟地址位段变少为两个：**页表索引、页内偏移** 。此时只有一个顶级页目录，包含1024个表项，每个表项指向一个物理页面，每个物理页面 4MB ，刚好表示 4GB 地址空间。结构如下：

![32位4Mb分页结构](../../static/imgs/03/02/030206.webp)

虚拟地址位段，1024个表项索引用10位表示，其余22位刚好表示4MB地址大小。

`CR3` 还是那个寄存器，此时指向页表项，页表项还是 4KB 对齐，低12位另作它用，结构如下：

![32位4MB页表项结构](../../static/imgs/03/02/030207.jpg)

## 长模式下分页

长模式下扩展了CPU位宽，变为64位，此时寻址能力大大增加，内存限制变小且内存地址空间变大。长模式下分页通常为两种：4KB 和 2MB 。

### 长模式 4KB 分页

4KB 分页下64位虚拟地址被分为6个位段，页表级数增多，每级项目有512个，每个项为64位8字节，仍为 4KB 大小，结构如下：

![64位4KB分页结构](../../static/imgs/03/02/030208.webp)

$8*512 * 8*512 * 8*512 * 8*512 = 2^{3}*2^{9} *... = 2^{48}$ 对应实现了48位的位宽。此时 `CR3` 为64位寄存器，指向顶级页目录物理基址。

> 虚拟地址中48-63这16位为保留位段，这里其值与第47位相同，这是因为 X86 CPU 没有实现全部64位总线，只实现了48位。这种最高有效位填充方式，即使以后扩展CPU地址总线也不会产生影响。

此时 `CR3` 、顶级页目录项、页目录指针项、页目录项、页表项的格式如下：

![64位页项结构](../../static/imgs/03/02/030209.jpg)

由于还是 4KB 对齐，所以低12位仍另作它用，最高位为执行位，可以判断代码页面是否可以运行。

### 长模式 2MB 分页

页面变大，位段相应减少，此时 64 位虚拟地址只有 5 个位段，各级表项仍然是 512 个项目数，每个项目为 64 位占 8 字节，放弃了页表项，页目录项直接指向物理页面，低22位用作页内偏移，22位刚好可表示 2MB 大小地址，其结构如下：

![64位2MB分页结构](../../static/imgs/03/02/030210.webp)

与 4KB分页类似，CR3、顶级页目录项、页目录指针项、页目录项的格式如下：

![64位2MB分页页级项结构](../../static/imgs/03/02/030211.jpg)

## 开启MMU

参见 [上一节](./硬件基础1--CPU工作模式.md) 。

## MMU地址转换失败

地址转换不会一直成功，用户程序访问管理者内存页面、向只读页面写入数据、发生缺页等都会造成MMU地址转换失败。

转换失败既不能 `reset` ，也不能放行，MMU大致会这样处理：

1. MMU把转换失败的虚拟地址写入CPU `CR2` 寄存器中。
2. MMU硬件触发CPU14号中断，CPU停止执行指令，处理中断。
3. CPU执行14号中断处理代码，代码会检查错误原因，处理好页面数据后返回。
4. CPU从中断返回，执行MMU地址转换失败后的指令。

----

## 总结

思维导图：

![本节思维导图总结](../../static/imgs/03/02/030212.jpg)

